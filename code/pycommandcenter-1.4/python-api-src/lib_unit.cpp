#include "library.h"

namespace py = pybind11;

void define_unit(py::module & m)
{
    py::class_<Unit>(m, "Unit")
        .def_property_readonly("unit_type", &Unit::getType, "The :class:`library.UnitType` of the unit")
        .def_property_readonly("position", &Unit::getPosition, "The :class:`library.Point2D` of the unit")
        .def_property_readonly("tile_position", &Unit::getTilePosition, "The :class:`library.Point2DI` of the unit")
        .def_property_readonly("hit_points", &Unit::getHitPoints, "Health of the unit.")
        .def_property_readonly("shields", &Unit::getShields, "Shield of the unit.")
        .def_property_readonly("energy", &Unit::getEnergy, "Energy of the unit.")
        .def_property_readonly("player", &Unit::getPlayer, "Returns the constant corresponding to player which this unit belongs to. See :ref:`playerconstants` for more information")
        .def_property_readonly("id", &Unit::getID, "Returns an int to identify the unit. Note: This value does not stay the same for units you lose vision of, so maybe not best idea to use as a way of keeping track of them.")
        .def_property_readonly("build_percentage", &Unit::getBuildPercentage, "Gives progress under construction. Range: [0.0, 1.0]. 1.0 == finished.")
        .def_property_readonly("weapon_cooldown", &Unit::getWeaponCooldown, "Time remaining for a weapon on cooldown.")
        .def_property_readonly("is_completed", &Unit::isCompleted, "Returns build_progress >= 1")
        .def_property_readonly("is_being_constructed", &Unit::isBeingConstructed, "Returns (build_progress > 0 and not is_completed)")
        .def_property_readonly("is_cloaked", &Unit::isCloaked, "If the unit is cloaked")
        .def_property_readonly("is_flying", &Unit::isFlying, "If the unit is flying.")
        .def_property_readonly("buffs", &Unit::buffs, "Returns a list buffs on this unit. Only valid for this player's units.")
        .def_property_readonly("is_alive", &Unit::isAlive, "Whether the unit is alive or not.")
        .def_property_readonly("is_powered", &Unit::isPowered, "Whether the unit is powered by a pylon.")
        .def_property_readonly("is_idle", &Unit::isIdle, "Wheter the unit has any orders")
        .def_property_readonly("is_burrowed", &Unit::isBurrowed, "If the unit is burrowed.")
        .def_property_readonly("is_valid", &Unit::isValid, "If the unit is valid")
        .def_property_readonly("is_training", &Unit::isTraining, "Returns True if the unit is a building and is traing another unit.")
        .def_property_readonly("is_blip", &Unit::isBlip, "Returns true if unit is a 'blip' - a ping on the map")
        .def_property_readonly("target", &Unit::getTarget, "Returns target unit if one exists, otherwise return itself")
        .def_property_readonly("has_target", &Unit::hasTarget, "Returns True if the target has a valid target and False otherwise")
        .def_property_readonly("max_hit_points", &Unit::getMaxHitPoints, "Returns the max health")
        .def_property_readonly("progress", &Unit::getProgress, "Returns the progress of currently used ability (-1 if not using ability)")
		.def_property_readonly("progression_list", &Unit::getAllProgress, "Returns a list containing the progression on all the processes in order. Empty list if no process exists")
        .def_property_readonly("current_ability_id", &Unit::getCurrentAbilityID, "The AbilityID of currently used ability")
        .def_property_readonly("facing", &Unit::getFacing, "Direction the unit faces in radians (1 radian == 57.296 degrees)")
        .def_property_readonly("radius", &Unit::getRadius, "Returns the radius of the unit")
        .def_property_readonly("is_carrying_minerals", &Unit::isCarryingMinerals, "Returns if this unit is currently holding minerals")
		.def_property_readonly("is_carrying_gas", &Unit::isCarryingGas, "Returns if this unit is currently holding gas")
		.def_property_readonly("gas_left_in_refinery", &Unit::gasLeftInGeyser, "Amount of vespene left in the the refinery.")
		.def_property_readonly("minerals_left_in_mineralfield", &Unit::mineralsLeftInMineralfield, "Amount of minerals if the unit is a mineral field.")
		.def_property_readonly("owner", &Unit::getOwner, "Which player owns a unit. Note: Not same as player. Player is from IDA implementation and owner is from sc2")
		.def_property_readonly("max_shields", &Unit::maxShields, "Max shield of the unit.")
		.def_property_readonly("max_energy", &Unit::maxEnergy, "Max energy of the unit.")

        .def("hold_position", &Unit::holdPosition, "Unit will hold its position")
        .def("patrol", py::overload_cast<const CCPosition &>(&Unit::patrol, py::const_), "Unit will patrol back and forth from its current location to the given Point2D")
        .def("stop_dance", &Unit::stopDance, "Unit will Stop and dance")
        .def("stop", &Unit::stop, "Unit will stop")
        .def("attack_unit", &Unit::attackUnit, "Unit will attack the provided unit")
        .def("attack_move", &Unit::attackMove, "Moves to provided Point2D location. If an enemy is seen on the way it will try to attack it. Will chase after the enemy as long as it is visible.")
        .def("ability", py::overload_cast<sc2::AbilityID>(&Unit::ability, py::const_))
        .def("ability", py::overload_cast<sc2::AbilityID, const CCPosition &>(&Unit::ability, py::const_))
        .def("ability", py::overload_cast<sc2::AbilityID, const Unit &>(&Unit::ability, py::const_))
        .def("move", py::overload_cast<const CCPosition &>(&Unit::move, py::const_))
        .def("move", py::overload_cast<const CCTilePosition &>(&Unit::move, py::const_))
        .def("right_click", &Unit::rightClick, "Same as right-clicking in the game, for example making workers mine minerals")
        .def("repair", &Unit::repair, "Right-clicks on the provided unit in order to repair it")
        .def("build", &Unit::build, "Build unit of type building_type at given position", "building_type"_a, "position"_a)
        .def("build_target", &Unit::buildTarget, "Build building_type on top of target Unit, useful for building refineries", "building_type"_a, "target"_a)
        .def("train", &Unit::train, "Train unit of type", "unit_type"_a)
        .def("morph", &Unit::morph, "Morph into type of unit_type", "unit_type"_a)
        .def("research", &Unit::research, "Research the given :class:`library.UPGRADE_ID`", "upgrade_id"_a)
        .def("is_constructing", &Unit::isConstructing, "unit_type"_a, "Returns true if the unit is currently constructing another unit of type `unit_type`. Note that `unit_type` needs to be an instance of :class:`library.UnitType`")
        .def("__hash__", [](const Unit & unit) { return std::hash<const sc2::Unit *>{}(unit.getUnitPtr()); })
        .def(py::self == py::self)
        .def("__repr__", [](const Unit & unit) { return "<Unit of type: '" + unit.getType().getName() + "'>"; });
}
